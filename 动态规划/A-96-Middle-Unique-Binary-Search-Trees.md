# A-96-Middle: Unique Binary Search Trees

## 考点

* 动态规划
* 卡特兰数
> 这个动态规划的推导给我们了另一种动态规划递推公式导出的方法，可以学习一下

要求以$1,2,3,...,n$序列组成的二叉搜索树的数目，设$f(n)$是这个数目。对于二叉搜索树，我们可以以$1,2,3,4,...,n$分别为根，设以$i$为根得到的二叉搜索树的数目为$g(i)$，则有$f(n)=g(1)+g(2)+g(3)+......+g(n-1)+g(n)$。要计算$g(i)$，注意到此时以$i$为根，树的左子树上有$1,2,3,4,...i-1$,右子树上有$i+1,i+2,...,n$。则左子树上的二叉搜索数的数目为$f(i-1)$，右子树上的数目为$f(n-i)$。所以有$g(i)=f(i-1)*f(n-i)$,因此

$$f(n)=f(0)*f(n-1)+f(1)*f(n-2)+...+f(n-1)*f(0)$$

其中边界条件为$f(0)=f(1)=1$

这个公式也就是所谓的 __卡特兰公式__

## 题解

```cpp
//卡特兰公式的实现
class Solution {
public:
    int numTrees(int n) {
       std::vector<long long> dp(n+1,0);
       dp[0]=dp[1]=1;
       for(int i=2;i<n+1;i++){
           for(int j=0;j<=i-1;j++){
               dp[i]+=(dp[j]*dp[i-1-j]);
           }
       }
       return dp[n];
    }
};
```

